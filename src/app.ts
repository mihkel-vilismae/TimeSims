// Main game entry point for TimeSims prototype.
// This file sets up a basic topâ€‘down 3D scene using Three.js, provides
// a simple timeline planning UI and plays back a deterministic
// simulation using the existing core logic in src/timesims/core.

import './style.css';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { simulatePlanning } from './timesims/core/simulation';
import type { TimelineCommand, TimelinePlan } from './model/components';

// Types for game objects in this app. These mirror the simulation types
// but include rendering state (meshes) for the 3D scene.
interface GameUnit {
  id: string;
  type: 'infantry' | 'tank' | 'ifv';
  mesh: THREE.Object3D;
  selectRing: THREE.Mesh;
  visionRadius: number;
  speed: number;
  plan: TimelinePlan;
  initialPos: { x: number; z: number };
}

interface GameEnemy {
  id: string;
  mesh: THREE.Object3D;
  pos: { x: number; z: number };
}

// Basic constants for the simulation.
const PREPARE_DURATION = 10;
const END_TIME = 25;
const DT = 0.1;

// Set up Three.js renderer, camera and scene.
const appDiv = document.getElementById('app') as HTMLDivElement;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
appDiv.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1116);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 15, 15);
camera.lookAt(0, 0, 0);

const raycaster = new THREE.Raycaster();
const pointerNdc = new THREE.Vector2();

let unitSelectEl: HTMLSelectElement | null = null;
let selectedUnitId: string | null = null;
let refreshCmdListFn: (() => void) | null = null;

function getSelectedUnitId(): string | null {
  if (selectedUnitId) return selectedUnitId;
  return unitSelectEl ? unitSelectEl.value : null;
}

function setSelectedUnitId(nextId: string) {
  selectedUnitId = nextId;
  if (unitSelectEl) unitSelectEl.value = nextId;
  for (const u of units) u.selectRing.visible = u.id === nextId;
  refreshCmdListFn?.();
}

// Resize handler to maintain aspect ratio.
window.addEventListener('resize', () => {
  const w = window.innerWidth;
  const h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});

// Add a simple ground grid to aid orientation.
const grid = new THREE.GridHelper(40, 40, 0x444444, 0x222222);
scene.add(grid);

// GLTF assets. These are loaded once at startup and then cloned for
// each instance in the scene. The assets live in src/assets/.  The
// names correspond to the file names generated by the asset script.
const assetFiles: Record<string, string> = {
  infantry: 'infantry.gltf',
  tank: 'tank.gltf',
  ifv: 'ifv.gltf',
  bunker: 'bunker.gltf',
  muzzle: 'muzzle_flash.gltf',
  projectile: 'projectile.gltf',
  smoke: 'smoke.gltf',
  weapon_small: 'weapon_small.gltf',
  weapon_large: 'weapon_large.gltf'
};

const assets: Record<string, THREE.Object3D> = {};
const loader = new GLTFLoader();
async function loadAssets() {
  const entries = Object.entries(assetFiles);
  for (const [key, fileName] of entries) {
    const url = new URL(`./assets/${fileName}`, import.meta.url).href;
    const gltf = await loader.loadAsync(url);
    assets[key] = gltf.scene;
  }
}

// Game world state.
const units: GameUnit[] = [];
const enemies: GameEnemy[] = [];
const buildings: { mesh: THREE.Object3D; pos: { x: number; z: number }; radius: number }[] = [];
let smokes: { pos: { x: number; z: number }; radius: number; startTime: number; endTime: number }[] = [];

// Simulation output state (populated when simulation runs).
let frames: { t: number; units: Record<string, { x: number; z: number }> }[] = [];
let markers: { t: number; kind: string; message: string }[] = [];
let warnings: string[] = [];
let playing = false;
let simTime = 0;
let markerIndex = 0;
let eventShown: Set<number> = new Set();

// UI elements.
const ui = document.getElementById('ui') as HTMLDivElement;
const markersContainer = document.getElementById('markersContainer') as HTMLDivElement;
const timelineContainer = document.getElementById('timelineContainer') as HTMLDivElement;
const eventList = document.getElementById('eventList') as HTMLDivElement;

// Helper to create a unit with mesh and visual aids (vision + fire radius).
function createUnit(id: string, type: 'infantry' | 'tank' | 'ifv', position: { x: number; z: number }, visionRadius: number, speed: number): GameUnit {
  const template = assets[type];
  const mesh = template.clone(true);
  mesh.position.set(position.x, 0, position.z);

  // Tag the hierarchy for pointer picking.
  mesh.traverse((o) => {
    o.userData = o.userData ?? {};
    o.userData.unitId = id;
  });

  scene.add(mesh);

  // Selection ring (visible only when selected).
  const ringGeom = new THREE.RingGeometry(0.6, 0.75, 48);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff66, opacity: 0.9, transparent: true, side: THREE.DoubleSide });
  const selectRing = new THREE.Mesh(ringGeom, ringMat);
  selectRing.rotation.x = -Math.PI / 2;
  selectRing.position.y = 0.02;
  selectRing.visible = false;
  mesh.add(selectRing);
  // Vision disk
  const visGeom = new THREE.CircleGeometry(visionRadius, 32);
  const visMat = new THREE.MeshBasicMaterial({ color: 0x3388ff, opacity: 0.2, transparent: true, side: THREE.DoubleSide });
  const visMesh = new THREE.Mesh(visGeom, visMat);
  visMesh.rotation.x = -Math.PI / 2;
  mesh.add(visMesh);
  // Fire radius disk (static small default for demonstration)
  const fireGeom = new THREE.CircleGeometry(4, 32);
  const fireMat = new THREE.MeshBasicMaterial({ color: 0xff4444, opacity: 0.1, transparent: true, side: THREE.DoubleSide });
  const fireMesh = new THREE.Mesh(fireGeom, fireMat);
  fireMesh.rotation.x = -Math.PI / 2;
  mesh.add(fireMesh);
  return {
    id,
    type,
    mesh,
    selectRing,
    visionRadius,
    speed,
    plan: { commands: [] },
    initialPos: { x: position.x, z: position.z }
  };
}

// Helper to create an enemy. For now enemies are static.
function createEnemy(id: string, position: { x: number; z: number }): GameEnemy {
  // For enemy, reuse the projectile model for a simple marker (red sphere)
  const geometry = new THREE.SphereGeometry(0.3, 16, 16);
  const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(position.x, 0.3, position.z);
  scene.add(mesh);
  return { id, mesh, pos: { x: position.x, z: position.z } };
}

// Helper to create a building that blocks LOS. Uses bunker model.
function createBuilding(position: { x: number; z: number }, radius: number) {
  const template = assets['bunker'];
  const mesh = template.clone(true);
  mesh.position.set(position.x, 0, position.z);
  scene.add(mesh);
  buildings.push({ mesh, pos: { x: position.x, z: position.z }, radius });
}

// Initialize the game after assets are loaded.
async function init() {
  await loadAssets();
  // Create units
  units.push(createUnit('infantry', 'infantry', { x: -4, z: 0 }, 8, 2));
  units.push(createUnit('tank', 'tank', { x: 0, z: -2 }, 10, 1.5));
  units.push(createUnit('ifv', 'ifv', { x: 4, z: 0 }, 8, 2.2));
  // Create a static enemy for demonstration
  enemies.push(createEnemy('enemy1', { x: 0, z: 12 }));
  // Create a building that blocks LOS
  createBuilding({ x: 2, z: 6 }, 1);
  // Setup UI components
  setupUI();

  // Initial selection
  if (units.length > 0) {
    setSelectedUnitId(units[0].id);
  }

  // Pointer selection in-scene (left click)
  renderer.domElement.addEventListener('pointerdown', (e) => {
    if (e.button !== 0) return;
    const hitId = pickUnitIdAtClient(e.clientX, e.clientY);
    if (hitId) setSelectedUnitId(hitId);
  });
  // Start rendering loop
  animate();
}

function pickUnitIdAtClient(clientX: number, clientY: number): string | null {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = (clientX - rect.left) / rect.width;
  const y = (clientY - rect.top) / rect.height;
  pointerNdc.set(x * 2 - 1, -(y * 2 - 1));

  raycaster.setFromCamera(pointerNdc, camera);
  const hits = raycaster.intersectObjects(
    units.map((u) => u.mesh),
    true,
  );
  for (const hit of hits) {
    let o: THREE.Object3D | null = hit.object;
    while (o) {
      const uid = o.userData?.unitId;
      if (typeof uid === 'string') return uid;
      o = o.parent;
    }
  }
  return null;
}

// Build the control panel UI.
function setupUI() {
  // Clear container
  ui.innerHTML = '';
  const title = document.createElement('h3');
  title.textContent = 'TimeSims Planner';
  ui.appendChild(title);
  // Unit selector
  const unitLabel = document.createElement('label');
  unitLabel.textContent = 'Unit:';
  ui.appendChild(unitLabel);
  const unitSelect = document.createElement('select');
  units.forEach((u) => {
    const opt = document.createElement('option');
    opt.value = u.id;
    opt.textContent = u.id;
    unitSelect.appendChild(opt);
  });
  ui.appendChild(unitSelect);
  unitSelectEl = unitSelect;
  if (!selectedUnitId) selectedUnitId = unitSelect.value;
  ui.appendChild(document.createElement('br'));
  // Start time and duration inputs
  const timeGroup = document.createElement('div');
  const startLabel = document.createElement('label');
  startLabel.textContent = 'start:';
  const startInput = document.createElement('input');
  startInput.type = 'number';
  startInput.step = '0.1';
  startInput.value = '0';
  startInput.style.width = '60px';
  const durLabel = document.createElement('label');
  durLabel.textContent = 'dur:';
  const durInput = document.createElement('input');
  durInput.type = 'number';
  durInput.step = '0.1';
  durInput.value = '2';
  durInput.style.width = '60px';
  timeGroup.appendChild(startLabel);
  timeGroup.appendChild(startInput);
  timeGroup.appendChild(durLabel);
  timeGroup.appendChild(durInput);
  ui.appendChild(timeGroup);
  // Direction inputs (for Move)
  const dirGroup = document.createElement('div');
  const dxLabel = document.createElement('label'); dxLabel.textContent = 'dx:';
  const dxInput = document.createElement('input'); dxInput.type = 'number'; dxInput.value = '0'; dxInput.style.width = '40px';
  const dzLabel = document.createElement('label'); dzLabel.textContent = 'dz:';
  const dzInput = document.createElement('input'); dzInput.type = 'number'; dzInput.value = '0'; dzInput.style.width = '40px';
  dirGroup.appendChild(dxLabel);
  dirGroup.appendChild(dxInput);
  dirGroup.appendChild(dzLabel);
  dirGroup.appendChild(dzInput);
  ui.appendChild(dirGroup);
  // Radius input (for smoke)
  const radiusGroup = document.createElement('div');
  const radiusLabel = document.createElement('label'); radiusLabel.textContent = 'rad:';
  const radiusInput = document.createElement('input'); radiusInput.type = 'number'; radiusInput.value = '4'; radiusInput.style.width = '40px';
  radiusGroup.appendChild(radiusLabel);
  radiusGroup.appendChild(radiusInput);
  ui.appendChild(radiusGroup);
  // Command buttons
  const buttons = document.createElement('div');
  const moveBtn = document.createElement('button'); moveBtn.textContent = 'Add Move';
  const fortBtn = document.createElement('button'); fortBtn.textContent = 'Add Fortify';
  const reloadBtn = document.createElement('button'); reloadBtn.textContent = 'Add Reload';
  const smokeBtn = document.createElement('button'); smokeBtn.textContent = 'Add Smoke';
  const refillBtn = document.createElement('button'); refillBtn.textContent = 'Add Refill';
  [moveBtn, fortBtn, reloadBtn, smokeBtn, refillBtn].forEach((b) => buttons.appendChild(b));
  ui.appendChild(buttons);
  // Command list display
  const cmdListTitle = document.createElement('h4'); cmdListTitle.textContent = 'Commands:';
  ui.appendChild(cmdListTitle);
  const cmdList = document.createElement('div');
  cmdList.style.maxHeight = '120px';
  cmdList.style.overflowY = 'auto';
  ui.appendChild(cmdList);
  // Run button
  const runBtn = document.createElement('button'); runBtn.textContent = 'Run Simulation';
  runBtn.style.marginTop = '4px';
  ui.appendChild(runBtn);

  // Helper to refresh the list of commands for the selected unit
  function refreshCmdList() {
    cmdList.innerHTML = '';
    const selId = getSelectedUnitId() ?? unitSelect.value;
    const unit = units.find((u) => u.id === selId);
    if (!unit) return;
    unit.plan.commands.sort((a, b) => a.startTime - b.startTime);
    unit.plan.commands.forEach((cmd, idx) => {
      const div = document.createElement('div');
      div.style.borderBottom = '1px solid #333';
      div.style.padding = '2px 0';
      div.textContent = `${idx + 1}. ${cmd.kind} @ ${cmd.startTime}s for ${cmd.duration}s`;
      cmdList.appendChild(div);
    });
  }
  refreshCmdListFn = refreshCmdList;
  unitSelect.addEventListener('change', () => {
    setSelectedUnitId(unitSelect.value);
  });

  // Add command handlers
  moveBtn.onclick = () => {
    const unit = units.find((u) => u.id === unitSelect.value);
    if (!unit) return;
    const start = parseFloat(startInput.value);
    const dur = parseFloat(durInput.value);
    const dx = parseFloat(dxInput.value);
    const dz = parseFloat(dzInput.value);
    const cmd: TimelineCommand = {
      id: `c${Date.now()}`,
      kind: 'move',
      startTime: start,
      duration: dur,
      direction: { x: dx, z: dz }
    } as any;
    unit.plan.commands.push(cmd);
    refreshCmdList();
  };
  fortBtn.onclick = () => {
    const unit = units.find((u) => u.id === unitSelect.value);
    if (!unit) return;
    const start = parseFloat(startInput.value);
    const dur = parseFloat(durInput.value);
    const cmd: TimelineCommand = {
      id: `c${Date.now()}`,
      kind: 'fortify',
      startTime: start,
      duration: dur
    } as any;
    unit.plan.commands.push(cmd);
    refreshCmdList();
  };
  reloadBtn.onclick = () => {
    const unit = units.find((u) => u.id === unitSelect.value);
    if (!unit) return;
    const start = parseFloat(startInput.value);
    const dur = parseFloat(durInput.value);
    const cmd: TimelineCommand = {
      id: `c${Date.now()}`,
      kind: 'reloadSpecial',
      startTime: start,
      duration: dur
    } as any;
    unit.plan.commands.push(cmd);
    refreshCmdList();
  };
  smokeBtn.onclick = () => {
    const unit = units.find((u) => u.id === unitSelect.value);
    if (!unit) return;
    const start = parseFloat(startInput.value);
    const dur = parseFloat(durInput.value);
    const rad = parseFloat(radiusInput.value);
    const cmd: TimelineCommand = {
      id: `c${Date.now()}`,
      kind: 'deploySmoke',
      startTime: start,
      duration: dur,
      radius: rad
    } as any;
    unit.plan.commands.push(cmd);
    refreshCmdList();
  };
  refillBtn.onclick = () => {
    const unit = units.find((u) => u.id === unitSelect.value);
    if (!unit) return;
    const start = parseFloat(startInput.value);
    const dur = parseFloat(durInput.value);
    const cmd: TimelineCommand = {
      id: `c${Date.now()}`,
      kind: 'refill',
      startTime: start,
      duration: dur
    } as any;
    unit.plan.commands.push(cmd);
    refreshCmdList();
  };

  // Run simulation handler
  runBtn.onclick = () => {
    runSimulation();
  };
  refreshCmdList();
}

// Convert game units to simulation snapshot and run simulation.
function runSimulation() {
  // Build world snapshot
  // Clone unit positions so simulation begins from initial position each run
  const world = {
    units: units.map((u) => ({
      id: u.id,
      pos: { x: u.initialPos.x, z: u.initialPos.z },
      visionRadius: u.visionRadius,
      plan: { commands: u.plan.commands.map((c) => ({ ...c })) },
      speed: u.speed
    })),
    enemies: enemies.map((e) => ({ id: e.id, pos: { x: e.pos.x, z: e.pos.z } })),
    buildings: buildings.map((b) => ({ pos: { x: b.pos.x, z: b.pos.z }, radius: b.radius })),
    smokes: [] as { pos: { x: number; z: number }; radius: number; startTime: number; endTime: number }[]
  };
  // Derive dynamic smoke occluders from deploySmoke commands
  world.units.forEach((u) => {
    u.plan.commands.forEach((cmd) => {
      if (cmd.kind === 'deploySmoke') {
        const sm = cmd as any;
        const pos = { x: u.pos.x, z: u.pos.z };
        const startTime = sm.startTime;
        const endTime = sm.startTime + sm.duration;
        world.smokes.push({ pos, radius: sm.radius, startTime, endTime });
      }
    });
  });
  // Reset playback state
  playing = false;
  simTime = 0;
  markerIndex = 0;
  eventShown.clear();
  eventList.innerHTML = '';
  markersContainer.innerHTML = '';
  // Run simulation
  const result = simulatePlanning(world, { dt: DT, prepareDuration: PREPARE_DURATION, endTime: END_TIME });
  frames = result.frames;
  markers = result.markers;
  warnings = result.warnings;
  // Draw marker bars along the timeline
  markers.forEach((mk) => {
    const div = document.createElement('div');
    div.className = 'marker';
    const left = (mk.t / END_TIME) * 100;
    div.style.left = `${left}%`;
    markersContainer.appendChild(div);
  });
  // Display warnings
  if (warnings.length > 0) {
    warnings.forEach((w) => {
      const li = document.createElement('div');
      li.textContent = `Warning: ${w}`;
      li.style.color = '#ffa07a';
      eventList.appendChild(li);
    });
  }
  playing = true;
}

// Update function executed every animation frame.  Drives playback of
// simulation, updates credit meter and displays events as they happen.
function animate() {
  requestAnimationFrame(animate);
  if (playing) {
    // Determine simulation frame index based on current time
    const idx = Math.min(frames.length - 1, Math.floor(simTime / DT));
    const frame = frames[idx];
    // Update unit meshes positions
    if (frame) {
      units.forEach((u) => {
        const p = frame.units[u.id];
        if (p) {
          u.mesh.position.set(p.x, 0, p.z);
        }
      });
    }
    // Show markers/events when their time has passed
    for (let i = markerIndex; i < markers.length; i++) {
      const mk = markers[i];
      if (mk.t <= simTime) {
        // Avoid showing detection and interrupt markers twice
        if (!eventShown.has(i)) {
          const li = document.createElement('div');
          li.textContent = `${mk.kind} @ ${mk.t.toFixed(1)}s: ${mk.message}`;
          eventList.appendChild(li);
          eventShown.add(i);
        }
        markerIndex = i + 1;
      } else {
        break;
      }
    }
    // Update credit meter
    const creditBar = document.getElementById('creditBar');
    const creditFill = document.getElementById('creditFill');
    if (creditBar && creditFill) {
      const progress = Math.max(0, Math.min(1, (simTime - PREPARE_DURATION) / (END_TIME - PREPARE_DURATION)));
      (creditFill as HTMLDivElement).style.width = `${progress * 100}%`;
    }
    // Advance simulation time (speed factor 1 real second ~ 1 sim second)
    simTime += DT * 0.5; // slow down playback (0.5x speed) for visibility
    if (simTime > END_TIME) {
      playing = false;
    }
  }
  // Render scene
  renderer.render(scene, camera);
}

// Kick things off
init().catch((err) => console.error(err));